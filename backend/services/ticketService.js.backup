const { GoogleGenerativeAI } = require('@google/generative-ai');
const config = require('../config');
const { supabase } = require('./supabaseClient');

const genAI = new GoogleGenerativeAI(config.gemini.apiKey);

/**
 * Generate a group key and summary for a message
 * Uses ULTRA-BROAD grouping - focuses on single core concept
 */
const generateGroupingMetadata = async (messageText, category) => {
  try {
    const model = genAI.getGenerativeModel({ model: config.gemini.model });

    // Ultra-simple prompt - forces broad, consistent grouping
    const prompt = `Extract 1-2 core words. Be VERY general. Use EXACT SAME words for similar requests.

CRITICAL: Use the SAME group_key for ALL messages about the same resource!

Examples (USE THESE EXACT PATTERNS):
"Need Supabase API key" â†’ {"group_key": "supabase-access"}
"Who has Supabase password?" â†’ {"group_key": "supabase-access"}
"Supabase credentials please" â†’ {"group_key": "supabase-access"}
"I need the Supabase key!" â†’ {"group_key": "supabase-access"}
"Where's database key?" â†’ {"group_key": "database-access"}
"GPT-4 broken" â†’ {"group_key": "gpt4-issue"}
"API down" â†’ {"group_key": "api-issue"}
"Can't login" â†’ {"group_key": "login-issue"}

RULES:
- 1-2 words ONLY (resource + action/topic)
- Drop: "need", "request", "help", "please", "issue"
- Keep: resource name + "access"/"issue"/"error"

Message: "${messageText}"

JSON only:
{"group_key": "resource-topic", "summary": "brief"}`;

    const result = await model.generateContent(prompt);
    const response = await result.response;
    let jsonText = response.text().trim();
    
    // Clean markdown
    jsonText = jsonText.replace(/```json\n?/g, '').replace(/```\n?/g, '').replace(/```/g, '');
    
    const metadata = JSON.parse(jsonText);
    
    // Force simplification: max 2 words
    if (metadata.group_key) {
      const parts = metadata.group_key.toLowerCase().split('-').filter(w => w.length > 2);
      metadata.group_key = parts.slice(0, 2).join('-');
    }
    
    console.log(`Generated group key: "${metadata.group_key}" from "${messageText.substring(0, 50)}..."`);
    return metadata;

  } catch (error) {
    console.error('Error generating grouping metadata:', error.message);
    // Fallback: use first 2 significant words
    const words = messageText.toLowerCase()
      .replace(/[^a-z0-9\s]/g, '')
      .split(/\s+/)
      .filter(w => w.length > 3);
    
    const groupKey = words.slice(0, 2).join('-') || 'unknown';
    
    return {
      group_key: groupKey,
      summary: messageText.substring(0, 100)
    };
  }
};

/**
 * Calculate similarity - VERY aggressive matching
 * Requires just ONE common word to match
 */
const calculateSimilarity = (key1, key2) => {
  const words1 = new Set(key1.split('-').filter(w => w.length > 2));
  const words2 = new Set(key2.split('-').filter(w => w.length > 2));
  
  if (words1.size === 0 || words2.size === 0) return 0;
  
  // Semantic keyword groups - if ANY match, boost heavily
  const semanticGroups = [
    new Set(['api', 'key', 'token', 'credential', 'password', 'secret', 'access', 'auth']),
    new Set(['supabase', 'database', 'db', 'postgres', 'sql']),
    new Set(['login', 'authentication', 'signin', 'signup', 'session']),
    new Set(['deploy', 'deployment', 'production', 'staging', 'build']),
    new Set(['error', 'bug', 'issue', 'problem', 'broken', 'failing', 'crash']),
    new Set(['setup', 'config', 'configuration', 'install', 'init']),
    new Set(['gpt', 'openai', 'ai', 'model', 'llm']),
  ];
  
  // Check for shared words from same semantic group
  let semanticBoost = 0;
  for (const group of semanticGroups) {
    const has1 = [...words1].some(w => group.has(w));
    const has2 = [...words2].some(w => group.has(w));
    
    if (has1 && has2) {
      semanticBoost = 0.5; // HUGE boost if same semantic category
      break;
    }
  }
  
  // Direct word overlap
  const intersection = new Set([...words1].filter(w => words2.has(w)));
  const union = new Set([...words1, ...words2]);
  
  const jaccardScore = intersection.size / union.size;
  
  // If ANY word matches, we're at least 33% similar
  const hasAnyMatch = intersection.size > 0 ? 0.33 : 0;
  
  // Return maximum of all scores
  return Math.min(1.0, Math.max(jaccardScore, hasAnyMatch, semanticBoost));
};

/**
 * Find matching ticket - VERY aggressive matching
 */
const findMatchingTicket = async (groupKey, category, summary) => {
  try {
    // Level 1: Exact match
    const { data: exactMatch, error: exactError } = await supabase
      .from('tickets')
      .select('*')
      .eq('group_key', groupKey)
      .eq('category', category)
      .in('status', ['open', 'in_progress'])
      .order('created_at', { ascending: false })
      .limit(1)
      .maybeSingle();

    if (exactError) throw exactError;
    if (exactMatch) {
      console.log('Exact match found:', exactMatch.group_key);
      return exactMatch;
    }

    // Level 2: Fuzzy match - VERY AGGRESSIVE
    const { data: candidates, error: fuzzyError } = await supabase
      .from('tickets')
      .select('*')
      .eq('category', category)
      .in('status', ['open', 'in_progress'])
      .limit(50); // Check many candidates

    if (fuzzyError) throw fuzzyError;

    let bestMatch = null;
    let bestScore = 0;
    const SIMILARITY_THRESHOLD = 0.25; // Only 25% needed! (1 word out of 4)

    for (const ticket of candidates) {
      const score = calculateSimilarity(groupKey, ticket.group_key);
      
      if (score >= SIMILARITY_THRESHOLD && score > bestScore) {
        bestScore = score;
        bestMatch = ticket;
      }
    }

    if (bestMatch) {
      console.log(`Fuzzy match found (${(bestScore * 100).toFixed(0)}% similar): "${bestMatch.group_key}" â‰ˆ "${groupKey}"`);
      return bestMatch;
    }

    console.log('ðŸ†• No matching ticket found - will create new');
    return null;
  } catch (error) {
    console.error('Error finding matching ticket:', error.message);
    return null;
  }
};

/**
 * Create a new ticket
 */
const createTicket = async (messageData, classification, groupKey, summary) => {
  try {
    const { data, error } = await supabase
      .from('tickets')
      .insert([
        {
          title: summary,
          category: classification.category,
          group_key: groupKey,
          similarity_summary: summary,
          first_channel_id: messageData.channel,
          first_user_id: messageData.user,
          status: 'open',
          is_fixed: false
        }
      ])
      .select()
      .single();

    if (error) throw error;
    console.log('Created new ticket:', data.id, '-', summary);
    return data;
  } catch (error) {
    console.error('Error creating ticket:', error);
    throw error;
  }
};

/**
 * Store a message in the database
 */
const storeMessage = async (messageData, classification, ticketId = null) => {
  try {
    const { data, error } = await supabase
      .from('messages')
      .insert([
        {
          ticket_id: ticketId,
          slack_ts: messageData.ts,
          slack_channel_id: messageData.channel,
          slack_user_id: messageData.user,
          slack_thread_ts: messageData.thread_ts || null,
          text: messageData.text,
          category: classification.category,
          is_relevant: classification.isRelevant,
          confidence: classification.confidence,
          reasoning: classification.reasoning,
          embedding_summary: classification.reasoning
        }
      ])
      .select()
      .single();

    if (error) {
      if (error.code === '23505') {
        console.log('âš ï¸  Duplicate message ignored:', messageData.ts);
        return null;
      }
      throw error;
    }

    return data;
  } catch (error) {
    console.error('Error storing message:', error.message);
    throw error;
  }
};

/**
 * Main grouping function
 */
const groupAndStoreMessage = async (messageData, classification) => {
  try {
    if (!classification.isRelevant) {
      await storeMessage(messageData, classification, null);
      console.log('ï¿½ï¿½ Stored irrelevant message');
      return { ticket: null, message: 'stored', grouped: false };
    }

    const { group_key, summary } = await generateGroupingMetadata(
      messageData.text,
      classification.category
    );

    console.log('Group key:', group_key);

    let ticket = await findMatchingTicket(group_key, classification.category, summary);

    if (ticket) {
      console.log('Matched to existing ticket:', ticket.id, '-', ticket.title);
      await storeMessage(messageData, classification, ticket.id);
      return { ticket, message: 'grouped', grouped: true };
    } else {
      ticket = await createTicket(messageData, classification, group_key, summary);
      await storeMessage(messageData, classification, ticket.id);
      return { ticket, message: 'new_ticket', grouped: false };
    }

  } catch (error) {
    console.error('Error in groupAndStoreMessage:', error.message);
    
    try {
      await storeMessage(messageData, classification, null);
      return { ticket: null, message: 'stored_without_grouping', error: error.message };
    } catch (storageError) {
      throw storageError;
    }
  }
};

const getAllTickets = async () => {
  try {
    const { data, error } = await supabase
      .from('tickets_with_counts')
      .select('*')
      .order('last_message_at', { ascending: false });

    if (error) throw error;
    return data;
  } catch (error) {
    console.error('Error fetching tickets:', error);
    throw error;
  }
};

const getTicketMessages = async (ticketId) => {
  try {
    const { data, error } = await supabase
      .from('messages')
      .select('*')
      .eq('ticket_id', ticketId)
      .order('created_at', { ascending: true });

    if (error) throw error;
    return data;
  } catch (error) {
    console.error('Error fetching ticket messages:', error);
    throw error;
  }
};

const updateTicketStatus = async (ticketId, status, isFixed) => {
  try {
    const { data, error } = await supabase
      .from('tickets')
      .update({ status, is_fixed: isFixed })
      .eq('id', ticketId)
      .select()
      .single();

    if (error) throw error;
    return data;
  } catch (error) {
    console.error('Error updating ticket status:', error);
    throw error;
  }
};

const deleteTicket = async (ticketId) => {
  try {
    const { error: messagesError } = await supabase
      .from('messages')
      .delete()
      .eq('ticket_id', ticketId);

    if (messagesError) throw messagesError;

    const { error: ticketError } = await supabase
      .from('tickets')
      .delete()
      .eq('id', ticketId);

    if (ticketError) throw ticketError;
    
    console.log('Deleted ticket:', ticketId);
    return true;
  } catch (error) {
    console.error('Error deleting ticket:', error);
    throw error;
  }
};

module.exports = {
  groupAndStoreMessage,
  getAllTickets,
  getTicketMessages,
  updateTicketStatus,
  deleteTicket,
  generateGroupingMetadata,
  findMatchingTicket
};
